\chapter{Aktoren}

In diesem Kapitel wird mit Aktoren ein Modell für nebenläufige Programmierung vorgestellt, dass ausschließlich auf asynchronen Nachrichtenaustausch basiert. Dieses Modell eignet sich vor allem für Systeme, in denen eine große Anzahl von Aufgaben gleichzeitigen ausgeführt wird. Zu diesen Szenarien zählen Systeme mit vielen Benutzer, gleichermaßen wie dem Internet der Dinge, das viele Geräte vernetzt.

Am Beginn dieses Kapitel werden die theoretischen Grundlagen des Aktorenmodells eingeführt. Anschließend wird mit der Sprache Erlang eine der ersten populären Implementierungen des Aktorenmodells präsentiert. Darauf aufbauend wird mit dem virtuellen Aktorenmodell eine mögliche Vereinfachung des Programmiermodells vorgestellt und diskutiert. Zum Abschluss dieses Kapitels wird noch die Beziehung des Aktorenmodells zur Microservice"=Architektur und anderen Technologien analysiert.

\section{Aktorenmodell}

Die ersten theoretischen Überlegungen des Aktorenmodells stellten \citeauthor{Hewitt:1973:UMA:1624775.1624804} bereits 1973 in \cite{Hewitt:1973:UMA:1624775.1624804} an. Hewitt beschreibt einen Aktor als fundamentale Recheneinheit die eine Möglichkeit benötigt \textit{Berechnungen} durchzuführen, einen \textit{Speicher} für Daten und die Fähigkeit zur \textit{Kommunikation} mit anderen Aktoren. Diese allgemeine Definition wird durch folgende drei Axiome ergänzt, die ein Aktor erfüllen muss:

\begin{itemize}
	\item Ein Aktor kann neue Aktoren erzeugen.
	\item Ein Aktor kann Nachrichten an andere Aktoren senden.
	\item Ein Aktoren kann sein Verhalten, dass bestimmt wie er auf die nächste Nachricht reagiert, ändern.
\end{itemize}

\noindent
Das Aktorenmodell ist nicht mit einem konkreten Programmierparadigma verbunden, sondern ein abstraktes Modell. Anschließend an diesen Abschnitt wird mit Erlang eine rein funktionale Implementierung vorgestellt und danach mit Project Orleans eine objektorientierte. Im Aktorenmodell finden sich viele Ideen aus der objektorientierten Programmierung, wie \zB Datenkapselung oder Nachrichtenaustausch wieder. Daher finden sich Entwickler mit einem Hintergrund in objektorientierter Programmierung oft sehr schnell mit der Funktionsweise des Aktorenmodells zurecht.

Ein einzelner Aktor hat nur begrenzte Möglihckeiten, daher kommen sie immer in ganzen Aktorsystemen vor. Da Aktoren eine sehr leichtgewichtige Einheit darstellen, können sehr viele Aktoren gleichzeitig in einem System existieren. Außerdem i das Erzeugen und Zerstören von Aktoren sehr effiziente Operationen. Aktoren bilden zur Laufzeit ein dynamisches Netzwerk, oder um es in der Sprache der Graphentheorie auszudrücken, einen gerichteten Graphen.

In sequentiellen Programmen wird Nebenläufigkeit meistens dadurch erreicht, dass mehrere Ausführungsstränge auf die selben Daten -- also den selben Speicherbereich -- zugreifen. Natürlich muss der Zugriff auf diese Daten geschützt und koordiniert werden, was diese Art der Programmierung schwierig und fehleranfällig macht. Nebenläufigkeit durch Aktoren, oder im allgemeinen durch Nachrichtenaustausch kann eine gute Alternative dazu sein. Aktoren besitzen keinerlei geteilten Speicher. Jede Information die sie benötigen müssen sie für sich selbst lokal speichern, oder als Teil einer Nachricht gesendet bekommen. Der Zustand eines Aktors ist somit für die Umwelt und damit auch für anderen Aktoren nicht sichtbar.

Die Verarbeitung der empfangen Nachrichten führt jeder Aktor sequentiell durch. Aber alle Aktoren können diesen Vorgang parallel durchführen. Gesamtheitlich gesehen ist dieses Modell also inhärent nebenläufig und somit gut skalierbar, auch wenn jeder Aktor für sich sequentiell ist. Je mehr Rechenkerne oder sogar Rechner zur Verfügung stehen, desto mehr Aktoren können gleichzeitig arbeiten.

Der Nachrichtenaustausch zwischen Aktoren erfolgt asynchron, \dh das Senden und das Empfangen der Nachricht ist entkoppelt. Eigentlich ist das Senden von Nachrichten asynchron, das Empfang jedoch ist für den Aktor eine synchrone \bzw blockierende Operation. Synchrone Kommunikation kann aber über Bestätigungsnachrichten nachgebildet werden. Bis zur tatsächlichen Verarbeitung einer Nachricht wird sie in einer Warteschlange zwischengespeichert. Manche Implementierungen des Aktorenmodells, darunter auch Erlang, unterstützen ein selektives Empfangen. Das bedeutet, dass nur bestimmte Nachrichten verarbeitet werden und andere in dieser Zeit in der Warteschlange verbleiben.

Das Aktorenmodell macht keine Annahmen darüber, ob es auf einem einzigen oder auf einen verteilten System angewendet wird. \Dah Programm die nach diesem Modell entwickelt sind, können ohne größere Änderung auf ein verteiltes System erweitert werden. Aktoren sind ohnehin nur über ihre Adressen angesprochen, die auch über Rechnergrenzen hinweg Bedeutung haben. Sie benötigen auch keinen gemeinsamen Speicherbereich, der in einem verteilten System ohnehin nicht existiert.

Obwohl Programme im Stile des Aktorenmodells in vielen Fällen einfacher sind als Systeme mit geteilten Speicher, schützt es dennoch nicht vor allen Herausforderungen der parallelen Programmierung. Probleme wie Deadlocks oder kritische Wettlaufsituation können durch falsche Anwendung dennoch entstehen. Aber später in diesem Kapitel genauer erläuterte Mechanismen wie Supervisorbäume und Zeitüberschreitungen helfen diese Probleme zu mindern.

\section{Erlang}
\label{sec:erlang}

Mit dem Ziel die Implementierung von hoch verfügbaren und verteilten Telekommunikationsanwendungen zu erleichtern, begann \citeauthor{Armstrong:1997:DE:258948.258967} 1985 die  Programmiersprache Erlang zu entwickeln~\cite{Armstrong:1997:DE:258948.258967}. In den Fokus seiner Bemühungen stellte er die Vereinfachung von nebenläufiger Programmierung. Die Begründung dahinter liegt darin, dass auch die reale Welt, die mit Software nachgebildet wird, inhärent nebenläufig ist. In jedem Augenblick passieren eine Unmenge an gleichzeitigen Ereignissen, die wir asynchron verarbeiten. Sequentielle Abläufe sind hier eher die Ausnahme. Trotzdem versuchen viele Programmiersprachen diese Tatsache zu ignorieren und stellen die sequentielle Hintereinanderausführung von Aktivitäten in den Vordergrund.

Um die Rolle der Nebenläufigkeit zu unterstreichen und Erlang von anderen Sprachen zu unterscheiden, bezeichnet Armstrong in \cite[19]{armstrong03} den Stil von Erlang als \textit{nebenläufigkeitsorientierte Programmierung}. Weitere wesentliche Einflussfaktor auf die Sprache sind die funktionale und teilweise die logische Programmierung, angelehnt an die Sprache Prolog.

Obwohl Erlang und das Aktorenmodell ein wenig in Vergessenheit geraten sind, erleben beiden derzeit wieder einen neuen Aufschwung. Das Interesse stieg vor allem wieder, nachdem die Kommunikationsplattform WhatsApp bekanntgab, dass sie mit ihren in Erlang entwickelten Plattform bis zu siebzig Millionen Nachrichten pro Sekunde verarbeiten~\cite{ErlangWhatsApp}.

\subsection{Einführung in die Sprache Erlang}

Dieser Abschnitt beinhaltet eine Einführung in die Syntax und Konzepte von Erlang, damit auch Leser ohne Vorkenntnisse in Erlang den Beispielen in diesem Kapitel folgen können. Die Sprache Erlang an sich ist wegen des minimalistischen Typsystems und der geringen Anzahl an Sprachfunktionen sehr einfach. Umfassendere Einführungen in Erlang geben die offizielle Dokumentation, \cite{Hebert:2013:LYE:2543986} und \cite{armstrong03}, auf denen auch ein wesentlicher Teil dieses Kapitels basiert.

\subsubsection{Typsystem}
\label{subsubsec:erlang-typesystem}

Die Sprache Erlang lässt sich als dynamisch und stark typisiert charakterisieren. Das sehr einfache Typsystem umfasst acht primitive und mit Tupel \bzw Listen zwei zusammengesetzte Datentypen, die nachfolgend noch erläutert werden.

In \cite{Marlow:1997:PSS:258948.258962} wurde versucht Erlang um ein statisches Typsystem zu erweitern, um Programmierfehler schon zur Übersetzungszeit zu identifizieren. Obwohl dieser Ansatz teilweise erfolgreich war, wurde er nicht weiter verfolgt, weil nicht alle Teile der Sprache typisiert werden konnten~\cite[14]{Armstrong:2007:HE:1238844.1238850}. Später wurde ein Werkzeug für leichtgewichtige statische Code"=Analyse mit dem Namen \textit{Dialyzer} entwickelt~\cite{ErlangWarStory}. Im Gegensatz zum dem in \cite{Marlow:1997:PSS:258948.258962} verfolgten Ansatz benötigt der Dializer keine zusätzlichen Typ"=Annotationen durch den Programmierer und erkennt dennoch die meisten Fehler die auch ein statisches Typsystem erkennen würde.

\subsubsection{Variablen}

Wie in vielen funktionalen Sprachen sind Variablen unveränderbar. \Dah es kann nur einmal ein Wert zugewiesen werden. In Erlang spricht man häufiger vom "`Binden"' einer Variable an einen Wert. Per Konvention beginnen alle Variablennamen mit einem Großbuchstaben. Programm~\ref{prog:erlang-vars} zeigt einige Beispiele für die Verwendung von Variablen.

\begin{program}[!hbt]
\caption{Verwendung von Variablen in Erlang}
\label{prog:erlang-vars}
\begin{ErlangCode}
Var1 = 1 + 2.
Var1 = Var1. % succeeds because left and right hand side are equal
Var2 = Var1 + 1. % succeeds and Var2 = 4.
Var1 = Var1 + 1. % fails because left and right side don't unify
\end{ErlangCode}
\end{program}

\subsubsection{Atome}

Atome bezeichnen in Erlang ein primitiven Datentyp, der wie ein Literal oder eine Konstante zu verstehen ist. Während Variablennamen immer mit einem Großbuchstaben beginnen, müssen Atome mit einem Kleinbuchstaben beginnen, damit sie unterscheidbar sind. In Programm~\ref{prog:erlang-atom} ist die Zuweisung eines Atoms an eine Variable gezeigt.

\begin{program}[!hbt]
\caption{Verwendung eines Atoms in Erlang}
\label{prog:erlang-atom}
\begin{ErlangCode}
Var3 = myatom.
\end{ErlangCode}
\end{program}

\subsubsection{Tupel und Listen}

Ein Tupel ist eine endliche Folge fixer Größe, die mehrere Elemente zu einem Verbund zusammenfasst. Die Anzahl der Elemente in einem Tupel ist endlich und nicht veränderbar. Neben Tupel besitzt Erlang auch einen Listentyp, der für eine beliebige Anzahl von Elementen aufnehmen kann. Im Gegensatz zu anderen Programmiersprachen müssen die Typen der Listenelemente nicht homogen sein. Tupel und Listen scheinen äußerlich sehr ähnliche Fähigkeiten zu haben. Generell gilt aber, dass Tupel für Datenstrukturen und Listen für Sequenzen von Elementen vorgesehen sind. Programm~\ref{prog:erlang-lists} zeigt einige Beispiele wie Listen deklariert werden können.

\begin{program}[!hbt]
\caption{Verwendung von Listen in Erlang}
\label{prog:erlang-lists}
\begin{ErlangCode}
Person1 = { alice, "Fake Street 42", 1234 }.
Person2 = { bob, "Main Avenue 1", 5678 }.
Person1 = { person, alice, "Fake Street 42", 1234 }. % mimics a class
List1 = [ 1, two, "three" ].
List2 = [ 1 | [2 | [ 3 | [] ] ] ].
List3 = [ Person1, Person2 ].
\end{ErlangCode}
\end{program}

\subsubsection{Module und Funktionen}

Module sind Dateien die mehrere logisch zusammengehörende Funktionen zu einer Einheit gruppieren. Das ermöglicht eine bessere Organisation des Quelltexts eines Programms und hilft Namenskonflikte aufzulösen. Nur Funktionen die explizit exportiert werden, sind von außerhalb aufrufbar. Ansonsten ist die Funktion nur innerhalb des definierenden Moduls sichtbar.

Eine Funktion besteht aus mehreren Funktionsanweisungen, die wiederum aus mehreren Ausdrücken bestehen können. Der Kopf einer Funktionsanweisung definiert ein Muster, das bei der Aktivierung einer Funktion mit den tatsächlichen Funktionsparametern verglichen wird. Diejenige Funktionsanweisung deren Muster als erstes mit den Funktionsparametern übereinstimmt, wird schlussendlich ausgeführt. In funktionalen Sprachen, somit auch in Erlang, wird ein Mustervergleich -- \textit{engl. Pattern Matching} -- oft für Fallunterscheidungen verwendet. Erlang unterstützt noch weitere Formen von Mustervergleichen, von denen einige im Laufe dieses Kapitels noch verwendet werden. In Programm~\ref{prog:erlang-module} ist die Deklaration eines Moduls und einer Funktion gezeigt. Die Funktion \lstinline{area} besteht aus vier Funktionsanweisungen mit unterschiedlichen Mustern im Kopf der Anweisung.

\begin{program}[!hbt]
\caption{Deklaration eines Moduls in Erlang}
\label{prog:erlang-module}
\begin{ErlangCode}
-module(shape).
-export([area/1]).
area({square, Width}) -> Width * Width;
area({rectangle, Width, Height}) -> Width * Height;
area({circle, Radius}) -> math:pi() * Radius * Radius;
area(_) -> erlang:error(unknown_shape).
\end{ErlangCode}
\end{program}

\subsection{Prozesse}
\label{subsec:erlang-processes}

Einer der zentralen Bestandteile von Erlang sind Prozesse. Dabei handelt es sich nicht um Betriebssystemprozesse, sondern leichtgewichtige Prozesse in der Erlang"=Laufzeitumgebung. Die Laufzeitumgebung ist eine abstrakte virtuelle Maschine, die viele Aufgaben eines Betriebssystem imitiert. Dazu zählen das Prozess"=Scheduling, der Nachrichtenaustausch, automatische Speicherbereinigung \usw

Mit der Funktion \lstinline{spawn} wird in Erlang ein neuer Prozess gestartet. Dabei muss als Argument eine Funktion, oder eine Funktionsbeschreibung der auszuführenden Funktion übergeben werden. Nachdem ein Prozess gestartet wurde, kann er Nachrichten von anderen Prozessen empfangen. Der Nachrichtenaustausch zwischen Prozessen erfolgt asynchron. Jeder Prozess besitzt eine eigene Warteschlange in der Nachrichten bis zur eigentlichen Verarbeitung zwischengespeichert werden.

Es gibt in Erlang keinen gemeinsamen Speicher, auf den mehrere Prozesse zugreifen können. Benötigt ein Prozess Informationen eines anderen Prozesses, muss er diese als Nachricht gesendet bekommen. Daraus ergibt sich ein sehr sauberes Programmiermodell, in dem ganz genau klar ist, wer die Verantwortung für die Speicherung bestimmter Daten hat und wie der Datenfluss aussieht. Im Gegensatz dazu ist es bei geteilten Daten, die von mehreren Stellen verändert werden, immer schwierig nachzuvollziehen wie eine Änderung zustande kam.

Das Senden einer Nachricht schlägt niemals fehl, selbst wenn der Empfänger nicht existiert. Ein synchroner Nachrichtenaustausch kann nur mit Hilfe von Bestätigungsnachrichten nachgebildet werden. Dabei ist es aber wichtig adäquate Zeitbeschränkungen zu verwenden, sodass Fehler, wie \zB ein abgestürzter Empfänger, erkannt werden können.

In Programm~\ref{prog:erlang-processes} sind einige wichtige Konstrukte im Zusammenhang mit Erlang"=Prozessen demonstriert. Die linke Spalte zeigt die Implementierung eines einfachen Prozesses, der Grundrechenoperationen mit Zahlen ausführen und das Zwischenergebnis auf dem Bildschirm ausgeben kann. In Zeile acht bis dreizehn in der linken Spalte wird ein Mustervergleich mit den empfangen Nachrichten durchgeführt. Je nach Nachricht wird eine andere Aktion ausgeführt. Der Zustand des Prozesses -- die Zwischensumme -- ist ein Parameter der Funktion \lstinline{loop}. Nach diesem oder einem ähnlichen Schema sind im Prinzip alle Prozesse in Erlang gestaltet. Da ein Prozess keine globalen Daten verändern kann, muss er seinen Zustand immer als Parameter in den nächsten Rekursionsschritt mitnehmen. Der Prozess in Programm~\ref{prog:erlang-processes} kann durch das Senden des Atoms \lstinline{stop} sauber beendet werden, da dieser Zweig der Nachrichtenbearbeitung keinen weiteren Rekursionsschritt mehr durchführt.

\begin{program}[!hbt]
\caption{Kommunikation zwischen Prozessen in Erlang}
\label{prog:erlang-processes}
\noindent\begin{minipage}[t]{.52\textwidth}
\lstset{showlines=true}
\begin{ErlangCode}
-module(calculator).
-export([init/0, loop/1]).

init() ->
  spawn(fun () -> loop(0) end).

loop(Total) ->
  receive
    { add,  X } -> loop(Total + X);
    { mult, X } -> loop(Total * X);
		{ divi, X } -> loop(Total / X);
    result      -> io:write(Total),
									 loop(Total);
    stop    		-> ok
  end.
\end{ErlangCode}

\end{minipage}\hfill
\begin{minipage}[t]{.44\textwidth}
\lstset{showlines=true}
\begin{ErlangCode}
% compile
c(calculator).
% start the process
Pid = calculator:init().
% send messages by process id
Pid ! { add, 6 }.
% register a name
register(calc_server, Pid).
% send messages by name
calc_server ! { mult, 7 }.
Pid ! result. % prints 42
calc_server ! stop.
% next message won't arrive,
% but no error is raised
calc_server ! result.
\end{ErlangCode}

\end{minipage}
\end{program}

Auf der rechten Seite in Programm~\ref{prog:erlang-processes} ist die Interaktion mit dem gerade erläuterten Prozess demonstriert. Der beschriebene Quelltext wird ebenfalls in einem Prozess ausgeführt, dessen Erzeugung aber nicht explizit dargestellt ist. In Zeile vier wird der Variable \lstinline{Pid} die eindeutige Prozess"=Identifikationsnummer des gestarteten Prozesses zugewiesen. Mit dieser Nummer können Nachrichten an den Prozess, sogar Rechnergrenzen übergreifend, adressiert werden. Wie Zeile sieben zeigt, kann auch ein Namen für einen gestarteten Prozess vergeben werden. Mit dem Infix"=Operator \lstinline{!} werden Nachrichten die jeden beliebigen Erlang"=Typ entsprechen können, an einen Prozess gesendet. Es ist jedoch zu beachten, dass eine vollständige Kopie der Nachricht versendet wird, weil möglicherweise die Nachricht  über das Netzwerk an einen entfernten Rechner zu transportieren ist.

\subsection{Open Telecom Platform}

Auch wenn Erlang die Entwicklung von hoch verfügbaren und skalierbaren Anwendungen wesentlich erleichtert, bleibt es dennoch mit den einfachen Möglichkeiten die Erlang bietet sehr zeitaufwändig und komplex. Aus diesem Grund wurden für viele immer wiederkehrende Aufgaben eine Bibliothek entwickelt, die allgemeine Probleme löst und den Entwickler viel Arbeit abnimmt.  Weil diese Bibliothek ursprünglich für Telekommunikationsanwendungen gedacht war, trägt sie den Namen \textit{Open Telecom Platform (OTP)}. Abgesehen vom Namen hat die Funktionalität dieser Bibliothek aber nichts mit dem Telekommunikationsbereich gemein und ist für alle Arten von Anwendungen geeignet. Neben sehr vielen nützlichen Hilfsfunktionen beinhaltet die OTP auch eine Menge Hilfswerkzeuge, wie \zB den Erlang"=Compiler oder das in \ref{subsubsec:erlang-typesystem} erwähnte Werkzeug für statische Code"=Analyse.

In den nachfolgenden Abschnitten werden mit Supervision und endlichen Automaten zwei wichtige Teilbereiche von Erlang erläutert. Für beide beinhaltet die OTP"=Bibliothek bereits generische Implementierungen. 

\subsection{Supervision}

Das Konzept der Supervision ist einer der Gründe, warum 
Erlang für besonders fehlertolerante Software bekannt ist. Ein weiterer Grund ist die Organisation der Programme in voneinander isolierte Prozesse, in denen jeder seine eigne Fehlerdomäne bildet. Wenn ein Prozess einen Fehler verursacht, sind andere Prozesse davon nicht direkt beeinflusst. Anstelle eines defensiven Programmierstils ist es in Erlang üblich Prozesse einfach abstürzen zu lassen, wenn sie ihre Arbeit nicht ordnungsgemäß ausführen konnten~\cite[104]{armstrong03}. Es ist die Aufgabe eines anderen Prozesses zu entscheiden wie mit einem Fehler umgegangen werden soll. Grundsätzlich werden Prozesse in zwei Kategorien eingeteilt, die immer paarweise auftreten:

\begin{itemize}
	\item \textit{Arbeiterprozesse} erledigen die eigentliche Arbeit und beinhalten kaum Fehlerbehandlungslogik.
	\item \textit{Supervisorprozesse} habe die Aufgabe Arbeiterprozesse zu überwachen und im Fehlerfall darauf zu reagieren.
\end{itemize}

Mehrere Prozesse können zu einer Einheit verbunden werden, sodass ein Absturz eines Prozesses, auch die anderen Prozesse beendet. Die Funktion \lstinline{link} erzeugt die beschriebene symmetrische Verbindung zwischen zwei Prozessen. Meistens wird aber die Funktion \lstinline{spawn_link} verwendet, die das Starten und Verbinden in einem atomaren Schritt durchführt. Ansonsten könnte es zu einer kritischen Wettlaufsituation kommen, in der ein Prozess terminiert, ohne die Prozesse rechtzeitig verbunden zu haben.

Nach dem Beenden eines Prozesses wird eine spezielle Nachricht an alle verbunden Prozesse gesendet, die sich daraufhin selbst beenden. Es gibt aber spezielle System"=Prozesse die eine Terminierungsnachricht wie eine gewöhnliche Nachricht empfangen und verarbeiten können. Um einen Prozess zu einem System"=Prozess zu befördern, muss lediglich die Eigenschaft \lstinline{trap_exit} gesetzt werden. System"=Prozesse übernehmen üblicherweise die Aufgaben eines Supervisors, da sie entscheiden können was mit den Arbeiterprozessen nach einem erwarteten oder unerwarteten Beenden geschehen soll.

In Programm~\ref{prog:erlang-supervision} wird der in Programm~\ref{prog:erlang-processes} implementierte Prozess um einen Supervisor erweitert. Immer wenn der Arbeiterprozess abstürzt, \zB bei einer Division durch Null, bekommt der Supervisor eine Terminierungsnachricht. Anschließend startet dieser den Arbeiterprozess neu. Diese extrem simplifizierte Fehlerbehandlungsstrategie ist für eine reelles Szenario selbstverständlich nicht ausreichend. Er versucht unendlich oft den Prozess sofort neu zu starten. Außerdem kann dieser Supervisor nur einen einzigen Arbeiterprozess überwachen. Im laufe dieses Abschnitts wird noch gezeigt, welche intelligenteren Strategien die OTP"=Bibliothek bietet.

\begin{program}[!hbt]
\caption{Prozessüberwachung in Erlang}
\label{prog:erlang-supervision}
\noindent\begin{minipage}[t]{.52\textwidth}
\lstset{showlines=true}
\begin{ErlangCode}
-module(sup).
-export([start/4, init/4]).

start(Name, M, F, A) ->
  spawn(?MODULE,init,[Name,M,F,A]).

init(Name, Mod, Fun, Args) ->
  process_flag(trap_exit, true),
  loop(Name, Mod, Fun, Args).

loop(N, M, F, A) ->
  register(N,Pid=spawn_link(M,F,A)),
  receive
    { 'EXIT', Pid, normal } -> ok;
    { 'EXIT', Pid, Reason } -> 
      loop(Name, M, F, A);
    { 'EXIT', From, _ } -> 
			exit(shutdown)
  end.
\end{ErlangCode}

\end{minipage}\hfill
\begin{minipage}[t]{.44\textwidth}
\lstset{showlines=true}
\begin{ErlangCode}
c(calculator), c(sup).
sup:start(
  calc_server, 
  calculator, loop, [0]
).

% find the id for a 
% registered name
whereis(calc_server).
% some id like <0.84.0>
calc_server ! {add, 1}.
calc_server ! { divi, 0 }.
% worker crashed

whereis(calc_server). 
% process was restarted and
% got a new id, but it can
% still addressed by name
calc_result ! result.
\end{ErlangCode}

\end{minipage}
\end{program}

Ein Verhalten -- \textit{engl. Behavior} -- in Erlang ist mit einer abstrakten Klasse in objektorientierten Sprachen vergleichbar. Es bietet eine gewissen Grundfunktionalität, die vom Verwender aber noch spezialisieren muss. \Dah der Verwender implementiert die vom Verhalten vorgegeben Funktionen, damit sie später vom Verhalten aufgerufen werden können. Das Supervisor-Verhalten erfordert lediglich eine Funktion mit dem Namen \lstinline{init}, die eine Datenstruktur wie in Programm~\ref{prog:erlang-supervision-behavior} gezeigt zurückgibt. Diese Datenstruktur beschreibt die Eigenschaften des Supervisor und definiert die Menge der überwachten Kindprozesse.

\begin{program}[!hbt]
\caption{Struktur einer Supervisorbeschreibung in Erlang}
\label{prog:erlang-supervision-behavior}
\begin{ErlangCode}
{ ok, 
  { {RestartStrategy, MaxRestart, MaxTime},
	  [ {ChildId, StartFunc, Restart, Shutdown, Type, Modules} ] } }.
\end{ErlangCode}
\end{program}

Es gibt verschiedene Strategien wie ein Supervisor seine überwachten Prozesse neu startet, wenn einer davon terminiert. Diese sind in Tabelle~\ref{tab:erlang-restart-strategy} aufgelistet.

Eine weitere wichtige Einstellung ist die Eigenschaft \lstinline{Restart} in der Spezifikation der Kindprozesse. Diese kann entweder den Wert \lstinline{permanent}, \lstinline{temporary} oder \lstinline{transient} annehmen. Permanente Prozesse werden immer neu gestartet, temporäre werden nie neu gestartet und transiente Prozesse werden nur neu gestartet, wenn sie nicht normal terminieren.

\begin{table}[!hbt]
\caption{Verschiedene Strategien in Erlang Prozesse neu zu starten}
\label{tab:erlang-restart-strategy}
\centering
\begin{tabular}{|l|p{8cm}|}
\hline
\emph{Strategie} & \emph{Erklärung} \\
\hline
\lstinline$one_for_one$ & Nur der beendete Prozess wird neu gestartet. \\
\hline
\lstinline$one_for_all$ & Alle übrigen Prozesse werden zuerst beendet und anschließend neu gestartet. \\
\hline
\lstinline$rest_for_one$ & Nur Prozesse die nach dem beendeten Prozess in der Startreihenfolge kommen werden gestoppt und neu gestartet. \\
\hline
\lstinline$simple_one_for_one$ & Diese Strategie kann nur eine Art von Prozess überwachen, aber davon beliebig viele dynamisch hinzugefügte Instanzen. Das ist in manchen Fällen effizienter als die Strategie \lstinline$one_for_one$. \\
\hline
\end{tabular}
\end{table}

Der nächste Abschnitt beschäftigt sich mit der Verteilung von Prozessen auf mehrere Rechner. Alle in diesem Abschnitt beschriebenen Mechanismen sind sowohl für lokale als auch für verteilte Szenarien anwendbar. Es macht keinen Unterschied ob sich Prozesse auf dem selben Rechner, oder einem entfernten Rechner befinden. Wirklich fehlertolerante Systeme müssen sogar zwangsläufig verteilt sein, um einen Hardwareausfall kompensiert zu können.

\subsection{Verteilte Prozesse}

Neben der Fehlertoleranz ist die verteilte Programmierung eine weitere Stärke von Erlang. Jede virtuelle Erlang"=Laufzeitumgebung stellt einen Knoten dar, der mit anderen Knoten verbunden werden kann. Dabei ist es egal ob alle Knoten auf nur einer einzigen oder mehreren Maschinen verteilt sind. Auf der Ebene des Betriebssystems ist jede Laufzeitumgebung ein eigener Betriebssystemprozess. So ist es sehr einfach einen großen Cluster für eine Testumgebung zu simulieren. Durch absichtliches Beenden eines Knotens kann eine Fehlersituation provoziert und somit die korrekte Behandlung derartiger Situationen getestet werden.

Alle bisher behandelten Konzepte, wie dem Erstellen von Prozessen, dem Senden von Nachrichten oder das Verbinden von Prozessen, bleiben auch in einem verteilten System unverändert. Was aber noch fehlt ist, Knoten zu verbinden und deren Zustand zu überwachen.

Jeder Knoten ist durch einen eindeutigen Namen identifiziert, der nach dem Format \lstinline{name@host} aufgebaut ist. Diese eindeutige Kennung ist ein Atom, dass aus zwei Teilen besteht. Der erste Teil ist ein frei definierbarer Name, der den Zweck hat mehrere Knoten auf dem selben Rechner zu unterscheiden. Der zweite Teil ist der DNS"=Name des Rechner. Es kann entweder der Host"=Name oder ein voll qualifizierter Domänenname verwendet werden. Es können sich nur Knoten verbinden, die beide dasselbe sogenannte \lstinline{Cookie} kennen. Ein Cookie ist mit einem gemeinsamen Geheimnis -- \textit{engl. Shared Secret} -- zu vergleichen und verhindert unerlaubten Zugriff auf den Cluster.

Um einen Prozess auf einem anderen Knoten zu Starten, kann der Funktion \lstinline{spawn}, die bereits aus Abschnitt~\ref{subsec:erlang-processes} bekannt ist, einfach als erstes Argument die eindeutige Kennung des Ziel"=Knotens übergeben werden. Es ist keine expliziter Verbindungsaufbau oder eine Registrierung des Knotens notwendig. Alle verbundenen Knoten werden automatisch im ganzen Cluster propagiert, sodass neue Knoten sofort Kenntnis über die gesamte Topologie haben. Semantisch ist es für ein Erlang"=Programm irrelevant, ob ein Prozess in der selben Erlang"=Laufzeitumgebung ausgeführt wird, oder auch einer entfernten.

Mit der Funktion \lstinline{monitor} kann ein Knoten den Zustand eines anderen Knotens überwachen. Sobald der überwachte Knoten nicht mehr erreichbar ist, bekommt der überwachende Prozess eine Nachricht zugestellt.

\begin{program}[!hbt]
\caption{Beispiel für die Verbindung von zwei Knoten in Erlang}
\label{prog:erlang-distributed}
\begin{ErlangCode}
> erl -sname alice -setcookie xyz
Eshell V8.3  (abort with ^G)
(alice@nodeA)1> nodes().
[]
(alice@nodeA)2> spawn(bob@nodeB, fun() -> ok end).
<7508.71.0>
(alice@nodeA)3> nodes().
[bob@nodeB]
(alice@nodeA)7> monitor_node(bob@nodeB, true).
true
(alice@nodeA)8> flush(). % fetches all messages for current process
Shell got {nodedown,bob@nodeB}
ok
(alice@nodeA)9> nodes().
[]
\end{ErlangCode}
\end{program}

\subsection{Austauschen von Code zur Laufzeit}

Computerprogramme die derartig robust sind, dass sie praktisch keine Stillstandszeiten aufweisen, mögen sich wie eine Utopie anhören. Doch genau dieser Wunsch war eine treibende Kraft die zur Entwicklung von Erlang führte. Gerade im Telekommunikationsbereich Anfang der achtziger Jahre war diese Anforderung von essentieller Bedeutung, weil erstens Stillstandszeiten nicht akzeptabel und zweitens redundante verteilte Systeme technisch noch nicht ausgereift waren. Um dieser Anforderung gerecht zu werden, wurde in Erlang eine Möglichkeit geschaffen, Code bei einem laufenden Programm auszutauschen. \Dah es möglich ein laufendes Programm um neue Funktionen zu erweitern oder Fehler zu beheben.

Eine Voraussetzung für diese Funktionalität ist die Fähigkeit Erlang"=Code zur Laufzeit zu übersetzen \bzw bereits übersetzten Code zu laden. In Programm~\ref{prog:erlang-processes} wurde bereits Gebrauch von der Funktion \lstinline{c} gemacht, die Erlang"=Quelltext übersetzt und anschließend lädt. Darüber hinaus gibt es noch die Funktion \lstinline{l}, die bereits übersetzten Code in die Laufzeitumgebung lädt.

In Erlang können zwei unterschiedliche Versionen des selben Moduls gleichzeitig geladen sein. Ein externer Funktionsaufruf, \dah ein Aufruf der mit dem Modulnamen qualifiziert ist, wird automatisch auf die zuletzt geladene Version verwiesen. Nicht qualifizierte Funktionsaufrufe zeigen weiterhin auf die ursprünglich geladene Version des Moduls. Ein einfaches Beispiel wie man Code zur Laufzeit aktualisieren kann, ist in Programm~\ref{prog:erlang-hot-code-loading} gezeigt.

\begin{program}[!hbt]
\caption{Austauschen von Code zur Laufzeit in Erlang}
\label{prog:erlang-hot-code-loading}
\noindent\begin{minipage}[t]{.49\textwidth}
\lstset{showlines=true}
\begin{ErlangCode}
-module(greeter).
-export([loop/1, upgrade/1]).
loop(State) -> receive
  greet -> 
    io:format("Version ~p.~n",
						  [State]),
    loop(State);
  update ->
    NewState = 
			?MODULE:upgrade(State),
    ?MODULE:loop(NewState)
end.
upgrade(OldState) -> 
  % upgrade state if necessary
  OldState + 1.
\end{ErlangCode}

\end{minipage}\hfill
\begin{minipage}[t]{.48\textwidth}
\lstset{showlines=true}
\begin{ErlangCode}
c(greeter).
Pid = spawn(greeter, loop, [1]).
Pid ! greet. % Version 1.
% recompile changed code
c(greeter).
% still the old message is shown
Pid ! greet. % Version 1.
Pid ! update.
Pid ! greet. % Version 2.






\end{ErlangCode}

\end{minipage}
\end{program}

Wie groß die Bedeutung von zur Laufzeit austauschbaren Code ist, lässt sich nicht so einfach beantworten. In Abschnitt~\ref{sec:immutable-server} wurde das Konzept von unveränderbaren Servern diskutiert, das teilweise im Widerspruch zu dem in diesem Abschnitt präsentierten Konzept steht. Der Ansatz dort konzentrierte sich auf den kompletten Austausch einer Deployment"=Einheit, bei jeder Änderung der Software. Im Prinzip wird ein vollständiger Server, egal ob virtuelle Maschine oder Container, einfach ersetzt. Dieser Ansatz ist noch um Blue"=Green Deployments und Canary"=Releasing erweiterbar~\cite[261-265]{Humble:2010:CDR:1869904}. Voraussetzung für ein Blue"=Green Deployment sind zwei identische Produktivsysteme. Die Umgebung auf der die aktuelle Softwareversion läuft und die den gesamten Datenverkehr abwickelt, wird die grüne Umgebung genannt. Neue Softwareversionen werden zunächst auf die zweite -- der blauen --Umgebung ausgerollt, intensiv getestet und aufgewärmt. Erst nach erfolgreichen Tests wird der Datenverkehr auf die blaue Umgebung umgelenkt. Canary"=Releases bezeichnen eine Technik bei der eine neue Softwareversion nur auf einen kleinen Teil der Produktivumgebung ausgerollt wird. Auch hier kann die neue Version intensiv getestet werden und sukzessive ein Teil des Produktivverkehrs auf diese Server umgeleitet werden. Auch damit können Fehler frühzeitig erkannt werden, ohne das gesamte Produktivsystem zu beeinträchtigen.

Mit den zuvor beschriebenen Methoden ist es nicht wirklich von Relevanz, Code zur Laufzeit austauschen zu können. Es ist aber nicht auszuschließen, dass Praktiken wie Blue"=Green Deplyoments \usw nur an Bedeutung gewonnen haben, weil viele Programmierumgebungen nicht die Möglichkeiten haben, wie sie Erlang bietet.

Welche Deplyoment"=Strategie zielführender ist, lässt sich nur situationsbedingt beantworten. Erlang forciert weder die eine noch die andere Strategie, oder auch in dieser Arbeit gar nicht betrachtete. Der Entwickler hat die Wahlfreiheit und kann sogar hybride Strategien entwerfen die im jeweiligen Anwendungsfall den größtmöglichen Nutzen bringen.

\subsection{Endliche Automaten}

Ein Programm in einen Aktorensystem besteht unter anderem aus einer Menge von Verhaltensdefinitionen, die bestimmen welche Aktionen ein Aktor nach dem Empfangen einer Nachricht ausführt und was das nächste Verhalten ist~\cite[30]{Agha:1986:AMC:7929}. Für die Formalisierung diese möglicherweise unendliche Definition, kann das mathematische Prinzip der Rekursion angewandt werden. Jedem Verhalten ist ein eindeutige Bezeichnung zugeordnet, die innerhalb der Definition als freie Variable vorkommen kann. Außerdem ist es möglich eine Verhaltensdefinition mit zusätzlichen Werte zu parametrisieren, die beim Wechsel in dieses Verhalten anzugeben ist.

Neben einer Menge von Verhaltensdefinitionen kann einer Aktor auch als nichtdeterministischer endlicher Automat, wie in Definition~\ref{def:nfs} eingeführt, beschrieben werden. Die Zustände des Automaten entsprechenden den Verhalten die ein Aktor annehmen kann. Als Eingangssymbole verarbeitet ein Aktor Nachrichten.

\newtheorem{nfstheorem}{Definition}[section]

\begin{nfstheorem}[{{\cite[87]{hopcroft2003}}}]
\label{def:nfs}

Ein nichtdeterministischer endlicher Automat ist definiert als 5-Tupel (Q, $\Sigma$, $\delta$, q0, F), wobei

\begin{itemize}
	\item Q eine endliche Menge von Zuständen,
	\item $\Sigma$ eine endliche Menge von Eingabesymbolen,
	\item $\delta : Q \times \Sigma \rightarrow \mathcal{P}(Q)$ mit $\mathcal{P} := \{ X | X \subseteq Q \}$ die Übergangsfunktion,
	\item $q0 \in Q$ der Startzustand und
	\item $F \subseteq Q$ eine Menge akzeptierender Zustände ist.
\end{itemize}

\end{nfstheorem}

Viele Abläufe lassen sich sehr gut als endlicher Automat beschreiben. In entsprechend visualisierter Form eigen sie sich auch um mit Domänenexperten bestimmten Abläufe, Vorgänge oder Geschäftsprozesse zu modellieren. Eine Spezifikation in Form eines endlichen Automaten lässt sich einfach in ein Aktorenprogramm transformieren. In Abbildung~\ref{fig:fsm-diag} ist schemenhaft ein Teil eines Zustandsautomaten der einen Warenkorb eines Versandhauses skizziert, dargestellt. In Programm~\ref{prog:erlang-fsm-pseudo} findet sich eine ebenfalls skizzierte und unvollständige Übersetzung dieses Automaten in ein Erlang"=Programm. Es ist gut zu erkennen, dass die Zustände als Funktionen definiert sind, die mit bestimmten, für ein Verhalten erforderlichen Werte, parametrisiert sind. Jede Funktion definiert auf welche Eingangssymbole -- hier Nachrichten -- sie wie reagiert. Das Wechseln in einen neuen Zustand ist lediglich ein weiterer Funktionsaufruf. Fraglich ist wie in einem bestimmten Zustand mit unerwarteten Nachrichten umgegangen werden soll. Diese Nachrichten könnten beispielsweise ignoriert werden oder einen Fehler auslösen, den der Supervisor behandeln muss. Entscheidend ist aber dass alle Nachrichten behandelt werden. Ansonsten ist es nicht mehr möglich weitere Nachrichten abzuarbeiten.

\begin{program}[!hbt]
\caption{Pseudocode eines endlichen Automaten}
\label{prog:erlang-fsm-pseudo}
\begin{ErlangCode}
empty() ->
	receive
		{ add, Product } -> ..., active([Product]);
		_ -> ??? % ignore? fail?
	end.
active(Products) ->
	receive
		{ add, P } -> ..., active([P|Products]);
		{ remove, P } -> if Products =:= [P] -> ..., empty();
												true -> ..., active(delete(P, Prodcuts));
										 end;
		{ setPayment, Method } -> waitingForAddress({Products,Method});
		...
	end.
waitingForAddress({Prods,Payment} -> ...
\end{ErlangCode}
\end{program}

\begin{figure}[!hbt]%
\caption{Teil eines endlichen Zustandsautomaten eines Warenkorbs}%
\label{fig:fsm-diag}%
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4.6cm]
  \node[state] (Emp)                 {Empty};
  \node[state]         (Act) [right of=Emp]  {Active};
  \node[state,align=left]         (Addr) [right of=Act] {Address\\Pending};

	\path[->]           (Emp) edge [bend left] node {Product added} (Act);
	\path[->]           (Act) edge [bend left] node {Product removed} (Emp);
	\path[->]           (Act) edge [loop above] node {Product added} (Act);
	\path[->]           (Act) edge [loop below] node {Product removed} (Act);
	\path[->]           (Act) edge [] node {Payment added} (Addr);
\end{tikzpicture}
\end{figure}

Endliche Automaten wie in Programm \ref{prog:erlang-fsm-pseudo} angedeutet kommen in Erlang sehr häufig vor. Aus diesem Grund enthält die OTP"=Bibliothek eine generische Implementierung dieses Muster. Das Erlang"=Verhalten \lstinline{gen_fsm} ist eine Schablone für einen endlichen Automaten, der asynchrone und synchrone Ereignisse verarbeitet.

\section{Elixir}

Nachdem Erlang fast ein viertel Jahrhundert erfolgreich für verteilte und fehlertolerante Systeme zum Einsatz kam, griff die Programmiersprache \textit{Elixir} die Prinzipien hinter Erlang erneut auf, verpachte sie in eine moderne Sprache und fügte hilfreiche Werkzeuge hinzu~\cite[9-10]{Loder2016}. Die Sprache selbst ist so wie Erlang auch dynamisch typisiert und zum Großteil der funktionalen Programmierung zuzuordnen. Ein wesentlicher Einflussfaktor auf die Syntax war die Sprache Ruby, von der vor allem die Möglichkeiten für Metaprogrammierung eingeflossen sind~\cite{ValimGoto2014}. Über sogenannte Makros, kann zur Übersetzungszeit Quelltext generiert werden. Damit können Entwickler die Sprache um eigene Kontrollstrukturen und eingebettete domänenspezifische Sprachen erweitern. Der draus resultierende Quelltext ist stark auf die Lösung des eigentlichen Problems konzentriert und nicht durch aufwändige syntaktische Konstrukte abgelenkt.

Sowohl Elixir, als auch Erlang, verwenden beide die virtuelle Erlang Maschine als Zielplattform. Diese ist besser bekannt unter dem Namen \textit{Bogdan's Erlang Abstract Machine (BEAM)}. Einige Implementierungen der virtuellen Erlang Maschine tragen die Namen der jeweiligen Entwickler. So auch die BEAM"=Maschine, die von Bogumil Hausman 1993 entwickelt wurde~\cite[12]{Armstrong:2007:HE:1238844.1238850}. In einer gewissen Weiße ist die virtuelle Erlang"=Maschine mit anderen virtuellen Maschinen wie der Java Virtual Machine oder der .NET Common Language Runtime vergleichbar. Es gibt viele Sprachen die von diesen abstrakten Maschinen ausführbaren Zwischencode erzeugen, der dann schlussendlich interpretiert oder in Maschinencode übersetzt wird.
Da beide Sprachen Code für die selbe Zielplattform generieren, ist es möglich Erlang"=Bibliotheken in Elixir zu verwenden und umgekehrt. Ebenso sind viele der bestehenden Werkzeuge für Erlang auch für Elixir anwendbar. Die meisten der in Abschnitt~\ref{sec:erlang} beschriebenen Konzepte auch in Elixir Gültigkeit. Angefangen beim Prozessmodell, über die Verteilungsaspekte bis hin zur Fehlertoleranz durch Supervisorbäume.

Es gibt kaum wissenschaftliche Studien, in denen die gefühlte Produktivitäts"= und Performanzsteigerungen durch den Einsatz von Umgebungen wie Elixir oder Erlang nachgewiesen sind. In \cite{ElixirIot} wurde der Einsatz von Elixir in einem IoT"=Szenario mit Java verglichen. Der signifikanteste Unterschied war die Menge an benötigten Quelltext, die bei Java mehr als dreimal so groß war. Auch der Speicherverbrauch der Implementierung in Elixir war wesentlich geringer, was großteils auf die sehr leichtgewichtigen Erlang"=Prozesse zurückzuführen ist. Für einen definitive Bestätigung der oben genannten Eindrücke fehlen aber weitere wissenschaftliche Beweise.

Die Entwicklung von Elixir hat gezeigt, dass die vor sehr langer Zeit in Erlang erforschten und erprobten Programmiermodelle bis heute relevant sind. Genau diese Konzepte können heutzutage für die Entwicklung von verteilten Systemen in der Web"=Entwicklung, im Internet der Dinge und anderen eingesetzt werden.

\section{Virtuelle Aktoren}

\section{Orleans}

\section{Aktorenmodell und Microservices}

- Don't start with a monolith
- Actormodel provides good modularization concepts
- No independent deployment? Hot Code Swapping? Most of the time unnecessary complexity. Only for really important components. Upgrade one node after the other
- More efficient communication (no REST/JSON) ...
- Understandable (state diagrams)

\iffalse

Basic Structure:
- Actor Model Basics
- Erlang
- Elixir
- Virtual Actor Pattern
- Orleans

\fi