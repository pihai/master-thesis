\chapter{Empfehlungen und Ausblick}

Das Ziel dieses Kapitels ist, die bisher betrachteten Konzepte zu reflektieren und Empfehlungen für geeignete Anwendungsgebiete zu geben. In manchen Bereichen stehen diese Konzepte in Konkurrenz zueinander und in anderen wiederum ergänzen sie sich. Für qualifizierte Technologieentscheidungen sind daher Empfehlungen wie die folgenden sehr wertvoll. Genau so wichtig ist es, zu erkennen, für welche Szenarien eine Technologie unvorteilhaft ist.

\section{Microservices}

Das Kapitel über Microservices hat sich eingehend der Frage gewidmet, welche Vorteile die Microservices"=Architektur gegenüber einer monolithischen Architektur bietet. Hierbei ist auch klar geworden, dass sich die Vorteile, wie entkoppelte Deployments, ein effizienterer Entwicklungsprozess oder der heterogene Technologieeinsatz, nur für Projekte von bestimmter Komplexität lohnen. Für kleine und neuartige Projekte ist die Microservice"=Architektur wenig geeignet. Vielmehr ist hier der Weg der evolutionären Softwarearchitektur zu empfehlen. Dabei wird eine bestehende -- \zB monolithische -- Anwendung sukzessive in eine Microservice"=Architektur umgewandelt. Bis zu einer bestimmten Größe \bzw Komplexität ist die Entwicklung einer monolithischen Anwendung effizienter als eine in Microservices zerlegte Anwendung. Änderungen und neue Funktionen lassen sich in einer monolithischen Architektur viel schneller umsetzen.

Nichtsdestotrotz ist die Microservice"=Architektur derzeit der führende Ansatz für die Entwicklung skalierbarer und robuster Anwendungen. Dabei skaliert dieser Ansatz nicht nur auf technischer sondern auch auf organisatorischer Ebene. Die Verteilung der Verantwortlichkeiten ermöglicht auch bei einer großen Anzahl von Entwicklern noch immer einen reibungslosen Entwicklungsprozess. Aber erst effiziente Bereitstellungsmethoden, wie PaaS, Container \ua, sowie leichtgewichtige Kommunikationsprotokolle haben den Erfolg von Microservices eingeleitet.

\section{Container-Technologien}

In den letzten Jahren hat sich die Virtualisierung durch Container stark weiterentwickelt. Getrieben wurden diese Entwicklungen hauptsächlich von Cloud"=Anbietern, die ein großes Interesse an der Reduzierung ihrer Infrastrukturkosten hatten. Nur mehr für sicherheitskritische Szenarien ist der Einsatz von virtuellen oder gar physischen Maschinen notwendig.

Aus Entwicklersicht hat ein Container alle Funktionen, die auch eine klassische virtuelle Maschine bietet. Ein Service in einem Container kann daher auf alle Technologien zurückgreifen, die das Container"=Betriebssystem unterstützt. Die Vorteile und Risiken von heterogenem Technologieeinsatz wurde bereits ausführlich erläutert.

Sowohl Microservices, als auch Container, haben die Philosophie, dass sie nur eine Aufgabe erfüllen. Jeder Microservice sollte daher ein eigener Container sein. Die Verwaltung von Anwendungen mit vielen Containern kann aber sehr aufwändig werden. An dieser Stelle ist es meistens notwendig, auf einen Container"=Orchestrierer zurückzugreifen. Dieser verteilt Container automatisch auf eine Menge von Maschinen. Außerdem gehört automatische Skalierung, Fehlerüberwachung und die Verwaltung des Lebenszyklus eines Containers zu den Vorzügen dieser Systeme.

\section{Serverlose Softwarearchitektur}

Function-as-a-Service wirkt wie der nächste logische Schritt in der Evolution von verwalteter Infrastruktur. Verwender sind vollständig von Aufgaben bezüglich Provisionierung und Skalierung von Infrastruktur freigestellt. Es handelt sich bei FaaS um eine produktive aber relativ unflexible, Möglichkeit, Funktionalität bereitzustellen. Mit fehlender Flexibilität ist hier gemeint, dass Entwickler keinen Einfluss darauf haben, wie die FaaS"=Plattform Funktionen bereitstellt. In vielen Szenarien ist aber große Flexibilität gar nicht notwendig. Hier kann FaaS vorteilhaft sein.

In vielen PaaS"=Technologien erfolgt die Kostenabrechnung anhand der Zeit, in denen Ressourcen zur Verfügung standen. Oft werden die Ressourcen aber gar nicht oder nur teilweise genutzt. Bei FaaS erfolgt die Verrechnung nur nach tatsächlich konsumierter Leistung. Gerade am Beginn von neuen Projekten kann dieses verbrauchsbezogene Verrechnungsmodell Kosten einsparen. Bei vorhersehbaren oder speziellen Lastaufkommen können aber optimierte alternative Lösungen die Kosten von FaaS unterbieten.

Die Zeit zwischen der Entwicklung von Funktionen und der tatsächlichen Verfügbarkeit für den Endbenutzer ist bei FaaS herausragend. Entwickler konzentrieren sich nämlich hauptsächlich auf Geschäftslogik und kaum mehr um Infrastrukturaufgaben. Mit nur wenigen Schritten sind die entwickelten Funktionen global, fehlertolerant und skalierbar bereitgestellt.

Das ereignisgesteuerte Programmiermodell von FaaS führt meistens zu einer lose gekoppelten Architektur. Damit ist es relativ unproblematisch, neue Funktionen hinzuzufügen \bzw bestehende zu ersetzen. Die Ereignisse kommen hauptsächlich aus anderen verwalteten Diensten, wie \zB von Datenbanken, Warteschlangen oder Zeitgebern. Auch die Ein"= und Ausgaben haben oft mit verwalteten Diensten zu tun. \Dah FaaS fokussiert sich auf die Integration von verwalteten Diensten und setzt dabei auf bestehende Standardkomponenten. In Systemen, die solche Komponenten bereits intensiv einsetzen, kann FaaS die notwendige Integrationslogik vereinfachen.

Für Anwendungen mit sehr geringen Latenzzeiten scheint FaaS derzeit noch kein geeigneter Ansatz zu sein. Wie in dieser Arbeit gezeigt wurde, wirken sich Kaltstarts signifikant auf die Latenzzeit aus. Außerdem sind viele Ereignisse mit einer Pull"=Strategie implementiert, die natürlich höhere Latenzzeiten als eine Push"=Strategie aufweist.

\section{Aktorenmodell}

Beim Aktorenmodell handelt es sich um ein formales Modell für nebenläufige Berechnungen. Dieser Ansatz eignet sich vor allem für Szenarien, in denen es eine große Anzahl von eigenständigen, gleichzeitig miteinander interagierenden Objekten gibt. Jedes dieser Objekte verarbeitet eingehende Nachrichten ausschließlich sequentiell und stellt somit eine koordinierte Verarbeitung sicher. Es lassen sich viele Softwaresysteme auf intuitive Weise als ein System von Aktoren darstellen. Beispielsweise können Benutzer, Geräte, Sensoren, Warenkörbe eines Onlineshops \usw als Aktor modelliert werden.

Wenn geringe Latenzzeiten für eine Anwendung essentiell sind, kann das Aktorenmodell eine gute Wahl sein. Denn obwohl jeder Aktor seine Nachrichten in einer Warteschlange zwischenspeichert, geschieht die Abarbeitung meistens sehr zeitnah. Es ist ohnehin selten, dass ein Aktor sehr viele Nachrichten verarbeitet. Die Skalierbarkeit des Aktorenmodells resultiert aus den vielen Aktoren, die parallel ihre Nachrichten sequentiell abarbeiten.

Aktoren teilen viele Gemeinsamkeiten mit Microservices. Beide sind relativ kleine Einheiten, die möglichst nur eine einzige Anforderung erfüllen. Sie agieren mit ihrer Umwelt ausschließlich über definierte Nachrichten. Aufgrund der Ähnlichkeit beider Ansätze ist es relativ einfach, aus einem Aktorensystem einzelne Microservices herauszulösen. Im Sinne der evolutionären Softwarearchitektur sollte dies nur bei einem triftigen Grund erfolgen.

Im Kapitel über das Aktorenmodell wurden verschiedene Implementierungen betrachtet. Es gibt aber auch noch weitere in dieser Arbeit nicht behandelte Varianten. Welche davon für eine Anwendung geeigneter ist, lässt sich nicht einfach pauschal beantworten. Aber wie der Vergleich zwischen Erlang und Orleans gezeigt hat, unterscheiden sich diese Varianten doch sehr wesentlich. Erlang bietet die größten Eingriffsmöglichkeiten, erfordert daher aber auch viel Implementierungsaufwand. Im Gegensatz dazu ist der Einstieg in Technologien wie Orleans etwas leichter. Es kann aber der Zeitpunkt kommen, an dem Orleans zu viele Entscheidungen für den Entwickler getroffen hat und die Flexibilität von Erlang wünschenswert wäre. Ebenfalls nicht zu vernachlässigen ist, dass Orleans auf der weit verbreiteten .NET"=Plattform aufsetzt. So können bestehende .NET"=Bibliotheken mit Orleans wiederverwendet werden.

Das Aktorenmodell lässt sich mit unterschiedlichen Programmierparadigmen implementieren. Die funktionale Programmiersprache Erlang verfolgt natürlicherweise einen funktionalen Ansatz. Im Gegensatz dazu hat Orleans mit der Objektorientierung ein Paradigma herangezogen, das vielen Entwicklern vertraut ist. Oft wirkt der funktionale Ansatz natürlicher. Beispielsweise sind die Zustände eines Aktors sehr intuitiv als Funktionen modelliert. Mit Hilfe von Mustervergleichen kann auch die Nachrichtenselektion prägnant formuliert werden. In objektorientierten Varianten ist es nicht sofort ersichtlich, in welchem Zustand sich ein Aktor befindet. Außerdem muss jede Methode eines Aktors den aktuellen Zustand überprüfen, was unweigerlich zu viel Entscheidungslogik führt. Aber diese beiden Ansätze unterscheiden sich nur äußerlich, funktional sind sie isomorph.

Viele Applikationen verwenden eine relationale Datenbank als externes Speichermedium. Mit persistenten Aktoren, so wie in Orleans, können Aktoren ihren Zustand automatisch mit einem externen Speicher synchronisieren. Es ist also nicht notwendig, die Daten noch separat in einer Datenbank zu speichern. Somit ist es auch nicht notwendig, eine Abbildung der objektorientierten Daten auf ein häufig relationales Datenmodell abzubilden.

Das Aktorenmodell war lange Zeit etwas in Vergessenheit geraten, obwohl schon von Beginn an brauchbare Implementierungen, wie \zB Erlang existierten. Für skalierbare und robuste Anwendungen ist ein verteiltes Programmiermodell unumgänglich. Mit dem Aufstieg von Cloud"=Computing und verteilter Programmierung, stieg auch das Interesse an Aktorensystemen wieder. Festzumachen ist diese Erkenntnis an den vielen neuen Implementierungen, die in den letzten Jahren erschienen sind. In Zukunft könnte das Aktorenmodell also mehr Bedeutung denn je bekommen.